{"head":{"title":"Serverless Framework - AWS Lambda Guide - Testing","menuText":"Testing","menuOrder":9,"description":"Recommendations and best practices for testing AWS Lambda Functions with the Serverless Framework","layout":"Page"},"body":"<!-- DOCS-SITE-LINK:START automatically generated  -->\n### [Read this on the main serverless docs site](https://www.serverless.com/framework/docs/providers/aws/guide/testing)\n<!-- DOCS-SITE-LINK:END -->\n<h1 id=\"testing\"><a href=\"#testing\" class=\"phenomic-HeadingAnchor\">#</a>Testing</h1>\n<p>Serverless introduces a lot of simplifications when it comes to serving business logic. We only need to provide handler function that almost entirely implements business logic. The only thing that we need to apply to are handler function arguments that are passed by FaaS provider. E.g. AWS Lambda passes 3 arguments <code>event</code>, <code>context</code> and <code>callback</code> to Node.js functions. Of course list of arguments differs between languages and, what is more important, between FaaS providers.</p>\n<p>Another important factor is a cloud environment. Basically, it's impossible to emulate AWS locally. Of course projects like <a href=\"http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBLocal.html\">dynamodb-local</a> or <a href=\"https://github.com/mhart/kinesalite\">kinesalite</a> may help but AWS (and other providers) provide much more services. We shouldn't rely on local implementations if we want to be 100% sure that our service won't fail after deploying to production environment.</p>\n<p>Because of those issues (and having <a href=\"http://martinfowler.com/bliki/TestPyramid.html\">test pyramid</a> in mind) we suggest following testing strategy:</p>\n<ul>\n<li>business logic should be independent from FaaS provider,</li>\n<li>unit testing should be used as a main tool for verifying business logic,</li>\n<li>integration tests should be used for verifying integration with other services.</li>\n</ul>\n<p>Let's take simple Node.js function as an example. The responsibility of this function is to save user into DB and send welcome email:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> db = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'db'</span>).connect();\n<span class=\"hljs-keyword\">const</span> mailer = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'mailer'</span>);\n\n<span class=\"hljs-built_in\">module</span>.exports.saveUser = <span class=\"hljs-function\">(<span class=\"hljs-params\">event, context, callback</span>) =></span> {\n  <span class=\"hljs-keyword\">const</span> user = {\n    <span class=\"hljs-attr\">email</span>: event.email,\n    <span class=\"hljs-attr\">created_at</span>: <span class=\"hljs-built_in\">Date</span>.now()\n  }\n\n  db.saveUser(user, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err</span>) </span>{\n    <span class=\"hljs-keyword\">if</span> (err) {\n      callback(err);\n    } <span class=\"hljs-keyword\">else</span> {\n      mailer.sendWelcomeEmail(event.email);\n      callback();\n    }\n  });\n};</code></pre>\n<p>There are two main problems with this functions:</p>\n<ul>\n<li>code is bounded to how AWS Lambda passes incoming data (<code>event</code> object),</li>\n<li>testing this function require running DB instance and mail server.</li>\n</ul>\n<h2 id=\"unit-testing\"><a href=\"#unit-testing\" class=\"phenomic-HeadingAnchor\">#</a>Unit testing</h2>\n<p>Business logic should be implemented in a way that allows using it in a different environment, no matter if it's AWS Lambda, Google Cloud Functions or HTTP server. Instead of writing complicated handler functions we should extract what is the core of our business. Let's extract it from above example</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Users</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>(db, mailer) {\n    <span class=\"hljs-keyword\">this</span>.db = db;\n    <span class=\"hljs-keyword\">this</span>.mailer = mailer;\n  }\n\n  save(email, callback) {\n    <span class=\"hljs-keyword\">const</span> user = {\n      <span class=\"hljs-attr\">email</span>: email,\n      <span class=\"hljs-attr\">created_at</span>: <span class=\"hljs-built_in\">Date</span>.now()\n    }\n\n    <span class=\"hljs-keyword\">this</span>.db.saveUser(user, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err</span>) </span>{\n      <span class=\"hljs-keyword\">if</span> (err) {\n        callback(err);\n      } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">this</span>.mailer.sendWelcomeEmail(email);\n        callback();\n      }\n  });\n  }\n}</code></pre>\n<p>This class is testable and doesn't require running any of the external services. Instead of real <code>db</code> and <code>mailer</code> objects we can pass mocks and assert if <code>saveUser</code> and <code>sendWelcomeEmail</code> has been called with proper arguments. We should have as much unit-test as possible and run them every code change. Of course passing unit-tests doesn't mean that our function is working as expected. That's why we also need integration test.</p>\n<h2 id=\"integration-tests\"><a href=\"#integration-tests\" class=\"phenomic-HeadingAnchor\">#</a>Integration tests</h2>\n<p>After extracting business logic to separate module handler function looks like this:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> db = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'db'</span>).connect();\n<span class=\"hljs-keyword\">const</span> mailer = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'mailer'</span>);\n<span class=\"hljs-keyword\">const</span> users = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'users'</span>)(db, mailer);\n\n<span class=\"hljs-built_in\">module</span>.exports.saveUser = <span class=\"hljs-function\">(<span class=\"hljs-params\">event, context, callback</span>) =></span> {\n  users.save(event.email, callback);\n};</code></pre>\n<p>It's responsible for setting up dependencies, injecting them and calling business logic functions. This code will be changed less often. To make sure that function is working as expected integration tests should be ran against deployed function. They should invoke function (<code>serverless invoke</code>) with fixture email address, check if user is actually saved to DB and check if email was received.</p>\n","__filename":"providers\\aws\\guide\\testing.md","__url":"/providers/aws/guide/testing/","__resourceUrl":"/providers/aws/guide/testing/index.html","__dataUrl":"/providers/aws/guide/testing/index.html.de8ba35a8f0bdd35ce47e70b69ba2dcd.json"}