{"head":{"title":"Serverless Variables","menuText":"Variables","menuOrder":10,"description":"How to use Serverless Variables to insert dynamic configuration info into your serverless.yml","layout":"Page"},"body":"<!-- DOCS-SITE-LINK:START automatically generated  -->\n### [Read this on the main serverless docs site](https://www.serverless.com/framework/docs/providers/aws/guide/variables)\n<!-- DOCS-SITE-LINK:END -->\n<h1 id=\"variables\"><a href=\"#variables\" class=\"phenomic-HeadingAnchor\">#</a>Variables</h1>\n<p>The Serverless framework provides a powerful variable system which allows you to add dynamic data into your <code>serverless.yml</code>. With Serverless Variables, you'll be able to do the following:</p>\n<ul>\n<li>Reference &#x26; load variables from environment variables</li>\n<li>Reference &#x26; load variables from CLI options</li>\n<li>Recursively reference properties of any type from the same <code>serverless.yml</code> file</li>\n<li>Recursively reference properties of any type from other YAML/JSON files</li>\n<li>Recursively nest variable references within each other for ultimate flexibility</li>\n<li>Combine multiple variable references to overwrite each other</li>\n</ul>\n<h2 id=\"reference-properties-in-serverlessyml\"><a href=\"#reference-properties-in-serverlessyml\" class=\"phenomic-HeadingAnchor\">#</a>Reference Properties In serverless.yml</h2>\n<p>To self-reference properties in <code>serverless.yml</code>, use the <code>${self:someProperty}</code> syntax in your <code>serverless.yml</code>. This functionality is recursive, so you can go as deep in the object tree as you want.</p>\n<pre><code class=\"hljs language-yml\"><span class=\"hljs-attr\">service:</span> new-service\n<span class=\"hljs-attr\">provider:</span> aws\n<span class=\"hljs-attr\">custom:</span>\n<span class=\"hljs-attr\">  globalSchedule:</span> rate(<span class=\"hljs-number\">10</span> minutes)\n\n<span class=\"hljs-attr\">functions:</span>\n<span class=\"hljs-attr\">  hello:</span>\n<span class=\"hljs-attr\">      handler:</span> handler.hello\n<span class=\"hljs-attr\">      events:</span>\n<span class=\"hljs-attr\">        - schedule:</span> ${self:custom.globalSchedule}\n<span class=\"hljs-attr\">  world:</span>\n<span class=\"hljs-attr\">      handler:</span> handler.world\n<span class=\"hljs-attr\">      events:</span>\n<span class=\"hljs-attr\">        - schedule:</span> ${self:custom.globalSchedule}</code></pre>\n<p>In the above example you're setting a global schedule for all functions by referencing the <code>globalSchedule</code> property in the same <code>serverless.yml</code> file. This way, you can easily change the schedule for all functions whenever you like.</p>\n<h2 id=\"referencing-environment-variables\"><a href=\"#referencing-environment-variables\" class=\"phenomic-HeadingAnchor\">#</a>Referencing Environment Variables</h2>\n<p>To reference environment variables, use the <code>${env:SOME_VAR}</code> syntax in your <code>serverless.yml</code> configuration file.</p>\n<pre><code class=\"hljs language-yml\"><span class=\"hljs-attr\">service:</span> new-service\n<span class=\"hljs-attr\">provider:</span> aws\n<span class=\"hljs-attr\">functions:</span>\n<span class=\"hljs-attr\">  hello:</span>\n<span class=\"hljs-attr\">      name:</span> ${env:FUNC_PREFIX}-hello\n<span class=\"hljs-attr\">      handler:</span> handler.hello\n<span class=\"hljs-attr\">  world:</span>\n<span class=\"hljs-attr\">      name:</span> ${env:FUNC_PREFIX}-world\n<span class=\"hljs-attr\">      handler:</span> handler.world</code></pre>\n<p>In the above example you're dynamically adding a prefix to the function names by referencing the <code>FUNC_PREFIX</code> env var. So you can easily change that prefix for all functions by changing the <code>FUNC_PREFIX</code> env var.</p>\n<h2 id=\"referencing-cli-options\"><a href=\"#referencing-cli-options\" class=\"phenomic-HeadingAnchor\">#</a>Referencing CLI Options</h2>\n<p>To reference CLI options that you passed, use the <code>${opt:some_option}</code> syntax in your <code>serverless.yml</code> configuration file.</p>\n<pre><code class=\"hljs language-yml\"><span class=\"hljs-attr\">service:</span> new-service\n<span class=\"hljs-attr\">provider:</span> aws\n<span class=\"hljs-attr\">functions:</span>\n<span class=\"hljs-attr\">  hello:</span>\n<span class=\"hljs-attr\">      name:</span> ${opt:stage}-hello\n<span class=\"hljs-attr\">      handler:</span> handler.hello\n<span class=\"hljs-attr\">  world:</span>\n<span class=\"hljs-attr\">      name:</span> ${opt:stage}-world\n<span class=\"hljs-attr\">      handler:</span> handler.world</code></pre>\n<p>In the above example, you're dynamically adding a prefix to the function names by referencing the <code>stage</code> option that you pass in the CLI when you run <code>serverless deploy --stage dev</code>. So when you deploy, the function name will always include the stage you're deploying to.</p>\n<h2 id=\"reference-variables-in-other-files\"><a href=\"#reference-variables-in-other-files\" class=\"phenomic-HeadingAnchor\">#</a>Reference Variables in Other Files</h2>\n<p>To reference variables in other YAML or JSON files, use the <code>${file(./myFile.yml):someProperty}</code> syntax in your <code>serverless.yml</code> configuration file. This functionality is recursive, so you can go as deep in that file as you want. Here's an example:</p>\n<pre><code class=\"hljs language-yml\"><span class=\"hljs-comment\"># myCustomFile.yml</span>\n<span class=\"hljs-attr\">globalSchedule:</span> rate(<span class=\"hljs-number\">10</span> minutes)</code></pre>\n<pre><code class=\"hljs language-yml\"><span class=\"hljs-comment\"># serverless.yml</span>\n<span class=\"hljs-attr\">service:</span> new-service\n<span class=\"hljs-attr\">provider:</span> aws\n<span class=\"hljs-attr\">custom:</span> ${file(./myCustomFile.yml)} <span class=\"hljs-comment\"># You can reference the entire file</span>\n<span class=\"hljs-attr\">functions:</span>\n<span class=\"hljs-attr\">  hello:</span>\n<span class=\"hljs-attr\">      handler:</span> handler.hello\n<span class=\"hljs-attr\">      events:</span>\n<span class=\"hljs-attr\">        - schedule:</span> ${file(./myCustomFile.yml):globalSchedule} <span class=\"hljs-comment\"># Or you can reference a specific property</span>\n<span class=\"hljs-attr\">  world:</span>\n<span class=\"hljs-attr\">      handler:</span> handler.world\n<span class=\"hljs-attr\">      events:</span>\n<span class=\"hljs-attr\">        - schedule:</span> ${self:custom.globalSchedule} <span class=\"hljs-comment\"># This would also work in this case</span></code></pre>\n<p>In the above example, you're referencing the entire <code>myCustomFile.yml</code> file in the <code>custom</code> property. You need to pass the path relative to your service directory. You can also request specific properties in that file as shown in the <code>schedule</code> property. It's completely recursive and you can go as deep as you want.</p>\n<h2 id=\"multiple-configuration-files\"><a href=\"#multiple-configuration-files\" class=\"phenomic-HeadingAnchor\">#</a>Multiple Configuration Files</h2>\n<p>Adding many custom resources to your <code>serverless.yml</code> file could bloat the whole file, so you can use the Serverless Variable syntax to split this up.</p>\n<pre><code class=\"hljs language-yml\"><span class=\"hljs-attr\">resources:</span>\n<span class=\"hljs-attr\">  Resources:</span> ${file(cloudformation-resources.json)}</code></pre>\n<p>The corresponding resources which are defined inside the <code>cloudformation-resources.json</code> file will be resolved and loaded into the <code>Resources</code> section.</p>\n<h2 id=\"nesting-variable-references\"><a href=\"#nesting-variable-references\" class=\"phenomic-HeadingAnchor\">#</a>Nesting Variable References</h2>\n<p>The Serverless variable system allows you to nest variable references within each other for ultimate flexibility. So you can reference certain variables based on other variables. Here's an example:</p>\n<pre><code class=\"hljs language-yml\"><span class=\"hljs-attr\">service:</span> new-service\n<span class=\"hljs-attr\">provider:</span> aws\n<span class=\"hljs-attr\">custom:</span>\n<span class=\"hljs-attr\">  myFlexibleArn:</span> ${env:${opt:stage}_arn}\n\n<span class=\"hljs-attr\">functions:</span>\n<span class=\"hljs-attr\">  hello:</span>\n<span class=\"hljs-attr\">      handler:</span> handler.hello</code></pre>\n<p>In the above example, if you pass <code>dev</code> as a stage option, the framework will look for the <code>dev_arn</code> environment variable. If you pass <code>production</code>, the framework will look for <code>production_arn</code>, and so on. This allows you to creatively use multiple variables by using a certain naming pattern without having to update the values of these variables constantly. You can go as deep as you want in your nesting, and can reference variables at any level of nesting from any source (env, opt, self or file).</p>\n<h2 id=\"overwriting-variables\"><a href=\"#overwriting-variables\" class=\"phenomic-HeadingAnchor\">#</a>Overwriting Variables</h2>\n<p>The Serverless framework gives you an intuitive way to reference multiple variables as a fallback strategy in case one of the variables is missing. This way you'll be able to use a default value from a certain source, if the variable from another source is missing.</p>\n<p>For example, if you want to reference the stage you're deploying to, but you don't want to keep on providing the <code>stage</code> option in the CLI. What you can do in <code>serverless.yml</code> is:</p>\n<pre><code class=\"hljs language-yml\"><span class=\"hljs-attr\">service:</span> new-service\n<span class=\"hljs-attr\">provider:</span>\n<span class=\"hljs-attr\">  name:</span> aws\n<span class=\"hljs-attr\">  stage:</span> dev\n<span class=\"hljs-attr\">custom:</span>\n<span class=\"hljs-attr\">  myStage:</span> ${opt:stage, self:provider.stage}\n\n<span class=\"hljs-attr\">functions:</span>\n<span class=\"hljs-attr\">  hello:</span>\n<span class=\"hljs-attr\">      handler:</span> handler.hello</code></pre>\n<p>What this says is to use the <code>stage</code> CLI option if it exists, if not, use the default stage (which lives in <code>provider.stage</code>). So during development you can safely deploy with <code>serverless deploy</code>, but during production you can do <code>serverless deploy --stage production</code> and the stage will be picked up for you without having to make any changes to <code>serverless.yml</code>.</p>\n<p>You can have as many variable references as you want, from any source you want, and each of them can be of different type and different name.</p>\n<h2 id=\"migrating-serverlessenvyml\"><a href=\"#migrating-serverlessenvyml\" class=\"phenomic-HeadingAnchor\">#</a>Migrating serverless.env.yml</h2>\n<p>Previously we used the <code>serverless.env.yml</code> file to track Serverless Variables. It was a completely different system with different concepts. To migrate your variables from <code>serverless.env.yml</code>, you'll need to decide where you want to store your variables.</p>\n<ul>\n<li>Using a config file: You can still use <code>serverless.env.yml</code>, but the difference now is that you can structure the file however you want, and you'll need to reference each variable/property correctly in <code>serverless.yml</code>. For more info, you can check the file reference section above.</li>\n<li>Using the same <code>serverless.yml</code> file: You can store your variables in <code>serverless.yml</code> if they don't contain sensitive data, and then reference them elsewhere in the file using <code>self:someProperty</code>. For more info, you can check the self reference section above.</li>\n<li>Using environment variables: You can instead store your variables in environment variables and reference them with <code>env.someEnvVar</code>. For more info, you can check the environment variable reference section above.</li>\n<li>Making your variables stage/region specific: <code>serverless.env.yml</code> allowed you to have different values for the same variable based on the stage/region you're deploying to. You can achieve the same result by using the nesting functionality of the new variable system. For example, if you have two different ARNs, one for <code>dev</code> stage and the other for <code>prod</code> stage, you can do the following: <code>${env:${opt:stage}_arn}</code>. This will make sure the correct env var is referenced based on the stage provided as an option. Of course you'll need to export both <code>dev_arn</code> and <code>prod_arn</code> env vars on your local system.</li>\n</ul>\n<p>Now you don't need <code>serverless.env.yml</code> at all, but you can still use it if you want. It's just not required anymore. Migrating to the new variable system is easy and you just need to know how the new system works and make small adjustments to how you store &#x26; reference your variables.</p>\n","__filename":"providers\\aws\\guide\\variables.md","__url":"/providers/aws/guide/variables/","__resourceUrl":"/providers/aws/guide/variables/index.html","__dataUrl":"/providers/aws/guide/variables/index.html.c0ed8a6f61390b1ce3a0b0f42e28aa54.json"}